#include<iostream>
using namespace std;

void bubbleSort(int*, int);

int main14() {
	int num1 = 10;
	// 指针的定义,指针存储的是16进制的地址变量->指针就是地址
	int* p = &num1;		// &可以取某个变量的地址
	cout << "num1在内存中的地址是：" << (int)&num1 << endl;
	cout << "指针变量p存储的地址为：" << (int)p << endl;

	// 使用指针地址内存中的变量，使用*号, *p 就是 变量 num1
	*p = 100;
	cout << "现在num1的数值为：" << num1 << endl;
	cout << "现在*p的数值为：" << *p << endl;

	// 指针变量占用的字节空间---不论是什么数据类型的指针（32位系统4字节，64位系统8字节）
	cout << "指针变量p占用的内存空间大小为：" << sizeof(p) << endl;
	cout << "指针变量double类型时占用的内存空间大小为：" << sizeof(double*) << endl;

	// 空指针,用于给指针变量进行初始化，空指针不能进行访问
	// 当直接 int* p; 不指定指向地址时，指向的地址是随机的，所以一般会指向NULL，NULL在初始被宏定义为了0
	// 空指针指向的内存空间为 0，是系统内存空间，可以指向，但是不能*访问，否则报错。 
	int* p2 = NULL;
	// int* p3;	// 该指针没有被初始化，无法打印指向地址是多少
	// int a;	变量没有被初始化时，也无法打印
	cout << "空指针存储的地址是：" << p2 << endl;
	// cout << "空指针指向地址的内容是：" << *p2 << endl;	// 引发了异常: 读取访问权限冲突。


	// 野指针,随便定义了一个16进制的地址空间然后去访问，并不是我们申请的空间，这样就是野指针，会报错，没有访问权限
	// int* p4 = (int*)0x11001;		// (int*) 将后面的16进制数强转为 int指针类型
	// cout << *p4 << endl;


	// 常量指针，在定义指针变量时，前面加上常量的标识 const 即可
	// 常量指针 指向一块地址(内存)后，该内存中的值就不能被  *p方式 修改了，但其他引用修改似乎可以
	// 但是该指针的指向可以被修改， p = &新地址，修改后同上
	const int* p5 = &num1;	// 常量指针指向 num1地址，const 实际上修饰的是 num1地址里面的东西，所以这个地址里面的东西不能改
	// *p5 = 50;


	// 指针常量，指针指向不能改，但是内存中的东西可以改
	int* const p6 = &num1;	// const 实际上修饰的是 指针的指向p6，所以指针的指向不能改
	// p6 = &num2;

	// 两个可以同时用
	const int* const p7 = &num1;
	// 此时不管是指针指向还是指向的值都不能改了


	// 使用指针访问数组
	int arr[10];
	//用数组地址遍历数组，给里面放值
	for (int i = 0; i < 10; i++)
	{
		arr[i] = i + 1;	
	}

	int* p_arr = arr;	// arr就是一个地址，指向数组的第一个元素
	// 实际上可以用 p_arr 当作 arr用，使用下标引用数组中的值，因为他俩的值是一样的
	cout << p_arr << "\t" << arr << endl;
	for (int i = 0; i < 10; i++)
	{
		p_arr[i] = i * 10;
	}
	
	// 但是arr不能当 p_arr 用，因为arr不能执行++，arr被绑定到了数组的第一个元素的地址上，无法修改
	for (int i = 0; i < 10; i++)
	{
		cout << "第" << i + 1 << "个位置的值是：" << *p_arr << endl;	// 此时p_arr指向数组的第一个元素地址
		p_arr++;	// 因为 p_arr 是整形指针，执行++，自动往后偏移4个字节，就到了第二个元素的地址（arr是整形数组，一个元素占4个字节）
	}

	bubbleSort(arr, 10);
	// 但是arr不能当 p_arr 用，因为arr不能执行++，arr被绑定到了数组的第一个元素的地址上，无法修改
	p_arr = arr;	// 将p_arr 恢复到 数组arr 初始元素位置
	for (int i = 0; i < 10; i++)
	{
		cout << "第" << i + 1 << "个位置的值是：" << *p_arr << endl;	// 此时p_arr指向数组的第一个元素地址
		p_arr++;	// 因为 p_arr 是整形指针，执行++，自动往后偏移4个字节，就到了第二个元素的地址（arr是整形数组，一个元素占4个字节）
	}

	return 0;
}

// 指针作为函数的参数,使用指针传递封装一个函数实现冒泡排序，c++不一定需要用返回值接收处理结果，直接传一个指针进去修改内容，不需要返回值
void bubbleSort(int* arr, int length) {
	for (int i = 0; i < length - 1; i++)
	{
		for (int j = 0; j < length - 1 - i; j++)
		{
			int temp_num = arr[j + 1];
			if (arr[j] < arr[j + 1])
			{
				arr[j + 1] = arr[j];
				arr[j] = temp_num;
			}
		}
	}
}
