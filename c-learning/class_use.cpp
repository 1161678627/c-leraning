#include<iostream>
using namespace std;
#include<string>
#include "point.h"
#include "circle.h"

//三种权限
//公共权限  public     类内可以访问  类外可以访问  （类外是指 类的实例化对象）
//保护权限  protected  类内可以访问  类外不可以访问 --- 可以被继承访问
//私有权限  private    类内可以访问  类外不可以访问 --- 不可以被继承访问

// 在class定义中，如果没有上属的权限标识 public:之类的，默认是私有权限
class Person
{
	int a;	// 默认私有权限
// 公共权限
// get set方法必须定义在public权限下
public:
	//Person() {}
	string P_name;
	void setAge(int age);
	int getAge();
	void setLover(string lover);

// 保护权限
protected:
	string P_car;

// 私有权限
private:
	// string P_name;
	int P_age;	// 可读可写--get set都有
	string P_lover; // 仅可写--仅有set

	
};

// 类的方法可以定义在类内，也可以在类内仅定义方法的声明，而把方法的实现放到类外，使结构更加清晰
void Person::setAge(int age)
{
	if ((P_age > 150) || (P_age < 0))
	{
		cout << "soory，年龄输入有误，初始化为0岁！" << endl;
		P_age = 0;
		return;	// 直接return出去---这样也算没有返回值
	}
	P_age = age;
	cout << "成功将年龄设置为：" << P_age << endl;
}

int Person::getAge()
{
	return P_age;
}

void Person::setLover(string lover)
{
	P_lover = lover;
	cout << "成功将Lover设置为：" << lover << endl;
}


// 判断点和圆关系的函数
void judge_distance(Point& p1, Circle& c) {
	Point p2 = c.getCenter();
	//cout << ((p1.get_X() - p2.get_X()) * (p1.get_X() - p2.get_X()) + (p1.get_Y() - p2.get_Y()) * (p1.get_Y() - p2.get_Y())) << endl;
	if (((p1.get_X() - p2.get_X()) * (p1.get_X() - p2.get_X()) + (p1.get_Y() - p2.get_Y()) * (p1.get_Y() - p2.get_Y())) < c.getCr() * c.getCr())
	{
		cout << "点在圆内" << endl;
	}
	else if (((p1.get_X() - p2.get_X()) * (p1.get_X() - p2.get_X()) + (p1.get_Y() - p2.get_Y()) * (p1.get_Y() - p2.get_Y())) > c.getCr() * c.getCr())
	{
		cout << "点在圆外" << endl;
	}
	else
	{
		cout << "点在圆上" << endl;
	}
}


// 类的构造函数和析构函数
/*
1. 构造函数，没有返回值也不写void
2. 函数名称与类名相同
3. 构造函数可以有参数，因此可以发生重载
4. 程序在调用对象时候会自动调用构造，无须手动调用,而且只会调用一次
当我们手动实现构造函数后，当实例化对象时，我们实现的构造函数会被自动调用（看重载哪个了）---如果我们没定义，系统会自动实现一个空的构造函数

1. 析构函数，没有返回值也不写void
2. 函数名称与类名相同,在名称前加上符号  ~
3. 析构函数不可以有参数，因此不可以发生重载
4. 程序在对象销毁前会自动调用析构，无须手动调用,而且只会调用一次
*/
class Persion1
{
public:
	Persion1();
	Persion1(int a);
	~Persion1();

private:
	int age;
};

Persion1::Persion1()
{
	cout << "没有任何参数的构造函数被调用了" << endl;
}

Persion1::Persion1(int a)
{
	age = a;
	cout << "有参数的构造函数被调用了" << endl;
}

Persion1::~Persion1()
{
	cout << "类要销毁了，析构函数被自动调用了" << endl;
}



// 静态属性和静态方法
class Person2
{
public:
	Person2();
	~Person2();
	int num3333;
	static int num1111;
	// int xx = 1;普通变量可以在类内给默认值，但静态变量不可以

	// 公有静态成员函数，只能访问静态成员变量，有两种方式访问1.类名，2.实例化对象访问
	static void test() {
		cout << "static 静态函数被调用" << endl;
		num1111 = 22;
		// num3333 = 5; 静态函数不能访问非静态成员变量
	}
	// 有的时候我们会习惯性的命名 形参和 类中变量一个名字，这样赋值的时候编译器会无法区分这几个变量
	// 如果我们使用this指针编译器就可以区分了，this指针指向调用这个函数的实例化对象
	// this指针用于解决名称冲突
	void test_this(int num3333) {
		this->num3333 = num3333;	// 调用指针下的对象，用 ->而不是.
		cout << this->num3333 << "被成功赋值！" << endl;
	}

private:
	// 私有静态成员函数，只能访问静态成员变量，只能在类内部访问，或者通过公有get set这种，实例化对象也无法访问
	static void test2() {
		cout << "私有 static 静态函数被调用" << endl;
		num1111 = 33;
		// num3333 = 5; 静态函数不能访问非静态成员变量
	}
	static int num2222;
};

Person2::Person2()
{
}

Person2::~Person2()
{
}

// 类外初始化静态变量---这个类外初始化不能放在任何函数中进行，必须在0缩进位置写
int Person2::num1111 = 10;
int Person2::num2222 = 99;	// 私有成员 静态变量，也要用类名初始化，公有私有都只能用类名初始化.但是公有静态数据可以通过类名继续访问，而私有就没法再用类名访问了
// int Person2::num2222 = 20;	// 不能多次初始化静态成员变量



// 继承
/*继承的好处：==可以减少重复的代码==
class A : public B; 
A 类称为子类 或 派生类
B 类称为父类 或 基类

**派生类中的成员，包含两大部分**：
一类是从基类继承过来的（除了私有属性、方法外的所有都可以继承），一类是自己增加的成员。
从基类继承过过来的表现其共性，而新增的成员体现了其个性。

#### 4.6.2 继承方式
继承的语法：`class 子类 : 继承方式  父类{子类的定义}
**继承方式一共有三种：**
* 公共继承---除了父类私有的属性继承不到，其他权限内容都继承得到，并不改变继承内容的权限
* 保护继承---除了父类私有的属性继承不到，其他权限内容都继承得到，并将其权限全部修改为子类的保护权限下
* 私有继承---除了父类私有的属性继承不到，其他权限内容都继承得到，并将其权限全部修改为子类的私有权限下*/



int main21() {
	Person p1;
	p1.setAge(22);
	cout << "p1的年龄是：" << p1.getAge() << endl;
	p1.setLover("xxxxx");

	// 实现案例点和圆的关系
	// 在一个类中，用另一个类作为属性，使用类的引用作为参数
	// 将类文件，也类似于函数文件拆分为头文件和实现源文件
	Point my_point;
	my_point.set_X(10);
	my_point.set_Y(0);

	Circle my_circle;
	my_circle.setCr(10);
	Point my_center;
	my_center.set_X(0);
	my_center.set_Y(0);
	my_circle.setCenter(my_center);

	judge_distance(my_point, my_circle);


	// 构造函数和析构函数
	// 调用默认构造函数时，不要 Persion1 person1(); 这样写编译器认为写了一个函数的声明，而不是实例化对象
	Persion1 person1;
	// 调用构造函数实例化对象
	// 方法1-括号法
	Persion1 person2(10);
	// 方法2-显示法
	Persion1 person3 = Persion1(10);
	// 方法3-隐式转换法
	Persion1 person4 = 10;	// 编译器会自动将这行代码转换为 Persion1 person4 = Persion1(10);



	/*
	默认情况下，c++编译器至少给一个类添加3个函数
	1．默认构造函数(无参，函数体为空)
	2．默认析构函数(无参，函数体为空)
	3．默认拷贝构造函数，对属性进行值拷贝
		---当在子函数中实例化一个局部的类对象时，return 该对象，就会调用拷贝构造，拷贝一份返回，实例化的局部变量在子函数调用结束时销毁
		---同理以值传递方式 将某个类的实例化对象传给 子函数时，值传递方式也会copy一份类对象，就会调用拷贝构造
		---调用拷贝构造函数，赋值操作，专门定义一个 拷贝构造函数，用于赋值一个已经有的类中的某些属性

	构造函数调用规则如下：
	* 如果用户定义有参构造函数，c++不在提供默认无参构造，但是会提供默认拷贝构造
	* 如果用户定义拷贝构造函数，c++不会再提供其他构造函数
	*/


	// 深拷贝与浅拷贝：总结：如果类属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题
	// 析构代码用于释放堆区开辟的内存空间


	// 构造函数初始化列表
	// Person(int a, int b, int c) :m_A(a), m_B(b), m_C(c) {}


	// B类中有 另一个 A类作为属性，且该属性在构造函数内初始化
	// 那么当创建B对象时，A与B的构造和析构的顺序是谁先谁后？  先构造A（子零件），再构造B（主体）。 先析构B（主体），再析构A（零件）

	/*
	*  静态成员变量---实际上静态就是指这个值被赋值的很早很早，甚至早于类的实例化，早于main的入口，这个类刚一声明完就赋值了，但是又不能在类内部赋值
	*  所有对象共享同一份数据---每个实例化对象都用的一个数据，一改大家都受影响---静态成员变量也有访问权限，static int a;这样定义即可,定义时不能赋初值
	*  在编译阶段分配内存---也许类都没实例化呢，这个静态变量的内存就已经有了
	*  类内声明，类外初始化---在类外使用 类名::静态变量名=xxx;初始化，不初始化的话，这块内存没办法访问
	*/

	
	// 因为上面实就进行了类外初始化，此时就可以实例化类对象了
	Person2 ppp2;
	cout << "类Person2的实例化对象ppp2静态属性num1111的值是：" << ppp2.num1111 << endl;
	Person2 ppp3;	// 在实例化一个对象也是公用同一个num1111值
	cout << "类Person2的实例化对象ppp3静态属性num1111的值是：" << ppp2.num1111 << endl;
	ppp3.num1111 = 100;		// 如果任何一个实例化对象修改了这个 静态变量的值，那么其他对象也会受牵扯。注意：静态变量用实例化对象访问时，也要受和普通变量一样的权限影响。get set之类的
	cout << "类Person2的实例化对象ppp2静态属性num1111的值是：" << ppp2.num1111 << endl;
	// 私有静态变量num222就不能这样访问了，道理同普通私有变量访问---私有的只有在实例化对象内才能访问（私有静态变量初始化除外）
	// cout << "类Person2的实例化对象ppp2静态属性num2222的值是：" << ppp2.num2222 << endl;

	// 当然公有静态成员，也可以类名::静态变量名  直接访问静态成员变量，类似于 类外初始化的方式，只不过初始化不能在任何函数体内而已
	cout << "类Person2的类名访问公有静态属性num1111的值是：" << Person2::num1111 << endl;
	// 注意私有静态变量，不可以通过类外的类名访问和修改的
	// cout << "类Person2的类名访问私有静态属性num2222的值是：" << Person2::num2222 << endl;

	/*
	*  静态成员函数---也是分权限的
	*  所有对象共享同一个函数
	*  静态成员函数只能访问静态成员变量---非静态成员变量无法访问
	*/
	// 调用 1.通过实例化的对象来调用
	ppp2.test();
	// 2.通过类名调用
	Person2::test();
	// 通过静态成员函数修改静态成员变量
	cout << "通过静态成员函数修改公有静态属性num1111的值是：" << Person2::num1111 << endl;
	// ppp2.test2()	// 类外无法访问私有静态成员函数，私有的只能在类内部访问，或者就是通过get set方法访问


	// 空对象占用内存空间大小为1字节，虽然他啥都没有，但是也得给个内存位置意思下，不然这实例化就废了，所以就给个最少的1字节。


	// this指针
	ppp2.test_this(10);
	// 在类的非静态成员函数中返回对象本身，可使用return* this---指定该函数的返回值为 Person&  引用返回，这样就不会创建一份新的对象了


	// 继承和权限
	// 1.公共继承
	//Son1 son1;
	//son1.m_a = 100;
	// son1.m_b = 500;	从父类继承过来的保护权限，类外访问不到

	// 2.保护继承
	//Son2 son2;
	// son2.m_a = 100;	因为是保护权限，所有父类中的公共属性m_a变为了子类中的保护权限，类外也无法访问

	// 3.私有继承---不再赘述
	// 父类中私有成员也是被子类继承下去了，只是由编译器给隐藏后访问不到---因此父类中的私有变量依旧会占用子类的内存

	// 父类和子类的构造和析构顺序，先构造父类再构造子类，析构顺序刚好相反。（创建子类对象的时候，也会创建一个父类对象用于继承的）


	// 继承中出现 子类和父类 同名的成员处理，子类是10，父类是100；显然直接访问的话，访问的是子类的属性
	// 访问子类同名成员   直接访问即可
	// 访问父类同名成员   需要加作用域（父类名称） --- son3.Base::m_a 这样就访问的是父类的属性或者方法了
	//Son3 son3;
	//cout << "子类中和父类重名的son3.m_a打印：" << son3.m_a << endl;
	/*1. 子类对象可以直接访问到子类中同名成员
	2. 子类对象加作用域可以访问到父类同名成员
	3. 当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数，加作用域可以访问到父类中同名函数*/
	// 注意：子类和父类 同名的静态属性、方法的访问方式和非静态基本一样。

	// 多继承可能会引发父类中有同名成员出现，需要加作用域区分
	// 多继承语法：   class 子类：继承方式 父类1 ，继承方式 父类2 {类定义} ---C++不推荐使用多继承开发程序

	// 菱形继承带来的主要问题是子类继承两份相同的数据，导致资源浪费以及毫无意义
	// 利用虚继承可以解决菱形继承问题


	return 0;
}